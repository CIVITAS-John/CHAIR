import { writeFileSync } from "fs";
import { dirname, resolve } from "path";
import { fileURLToPath } from "url";

import { HumanMessage, SystemMessage } from "@langchain/core/messages";
import { PythonShell } from "python-shell";

import type { BertopicTopics, CodedThread, Conversation, Message } from "../schema.js";
import { ensureFolder, getPythonPath } from "../utils/file.js";
import { requestLLM } from "../utils/llms.js";
import { logger } from "../utils/logger.js";

import { buildMessagePrompt, ConversationAnalyzer } from "./conversations.js";

/**
 * Conduct the first-round bertopic coding of the conversations.
 * @author John Chen
 */
export default class BertopicAnalyzerAny extends ConversationAnalyzer {
    /** The name of the analyzer. */
    override name = "bertopic-any";
    /** The base temperature for the LLM. */
    override baseTemperature = 0.5;
    /** The codes generated by Bertopic. */
    #codes: Record<string, string> = {};

    /**
     * Get the chunk size and cursor movement for the LLM.
     * @returns [Chunk size, Cursor movement]
     */
    override getChunkSize(_recommended: number, remaining: number) {
        return remaining;
    }

    /** Preprocess the conversations in batch. */
    override async batchPreprocess(
        conversations: Conversation[],
        _analyzed: CodedThread[],
    ): Promise<void> {
        await logger.withSource(this._prefix, "batchPreprocess", true, async () => {
            // Write the messages into the file.
            const messages = conversations.flatMap((conversation) =>
                conversation.items.filter(
                    (message) =>
                        // TODO: Support subchunks
                        "content" in message &&
                        message.content.length > 0 &&
                        (!message.chunk || message.chunk === conversation.id),
                ),
            );
            const content = messages.map((message) =>
                // TODO: Support subchunks
                "content" in message
                    ? buildMessagePrompt(
                          this.dataset,
                          message,
                          undefined,
                          undefined,
                          true,
                      ).replaceAll("\n", " ")
                    : "",
            );
            ensureFolder("./known");
            writeFileSync("./known/bertopic.temp.json", JSON.stringify(content));
            // Run the Python script
            let topics: BertopicTopics = {};
            const __dirname = dirname(fileURLToPath(import.meta.url));
            await PythonShell.run(resolve(__dirname, "bertopic_impl.py"), {
                pythonPath: getPythonPath(),
                args: [messages.length.toString()],
                parser: (message) => {
                    if (message.startsWith("{")) {
                        logger.success(message);
                        topics = JSON.parse(message) as BertopicTopics;
                    } else {
                        logger.warn(message);
                    }
                },
            });
            // Generate a label and definition for each topic
            for (const topic of Object.values(topics)) {
                const ids = topic.ids.sort(
                    (A, B) => topic.probabilities[B] - topic.probabilities[A],
                );
                // Maximum 5 examples sorted by probabilities
                const examples = ids.slice(0, 5).map((ID) => messages[ID]);
                // Build the prompt
                const prompt = `
You are an expert in thematic analysis with grounded theory, working on open coding.
You identified a topic from the input quotes. Each quote is independent from another.
${this.dataset.researchQuestion}
${this.dataset.codingNotes}

Always follow the output format:
===
Thought: {What is the most common theme among the input quotes? Do not over-interpret the data.}
Label: {A single label that faithfully describes the topic}
===`.trim();
                // Find 5 keywords from the topic
                const keywords = topic.keywords.slice(0, 5);
                // Request the LLM
                const response = await requestLLM(
                    this.session,
                    [
                        new SystemMessage(prompt),
                        new HumanMessage(
                            `Quotes:
${examples
    .map((message) =>
        // TODO: Support subchunks
        "content" in message
            ? `- ${buildMessagePrompt(this.dataset, message, undefined, undefined, true)}`
            : "",
    )
    .join("\n")}
Keywords: ${keywords.join(", ")}`.trim(),
                        ),
                    ],
                    `messaging-groups/${this.name}`,
                    this.baseTemperature,
                    false,
                );
                // Parse the response
                let phrase = "";
                const lines = response.split("\n");
                for (const _line of lines) {
                    const line = _line.trim();
                    if (line.startsWith("Label:")) {
                        phrase = line.slice(6).trim().toLowerCase();
                        if (phrase.endsWith(".")) {
                            phrase = phrase.slice(0, -1);
                        }
                    }
                }
                // Assign messages to the topic
                for (const id of ids) {
                    this.#codes[messages[id].id] = phrase;
                }
            }
        });
    }

    /** Parse the response from the LLM. */
    override parseResponse(
        _analysis: CodedThread,
        _lines: string[],
        subunits: Message[],
        _chunkStart: number,
        _iteration: number,
    ): Promise<Record<number, string>> {
        const results: Record<number, string> = {};
        for (let i = 0; i < subunits.length; i++) {
            let code = this.#codes[subunits[i].id] ?? "";
            // Sometimes, the code ends with a period
            if (code.endsWith(".")) {
                code = code.slice(0, -1);
            }
            // Sometimes, the code is inside a quote
            if (code.startsWith('"') && code.endsWith('"')) {
                code = code.slice(1, -1);
            }
            results[i + 1] = code;
        }
        return Promise.resolve(results);
    }
}
